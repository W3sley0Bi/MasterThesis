<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Static RDF Graph from JSON‑LD with Dynamic Legend, Highlighting & Blurred Text</title>
  <!-- Load vis-network CSS from CDN -->
  <link href="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.css" rel="stylesheet" />
  <style>
    /* Container for the network & overlay legend */
    #network-container {
      position: relative;
      width: 100%;
      height: 600px;
      border: 1px solid lightgray;
      margin-bottom: 20px;
    }
    /* Network canvas fills the container */
    #mynetwork {
      width: 100%;
      height: 100%;
    }
    /* Legend overlay styling */
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      border: 1px solid #ccc;
      padding: 10px;
      z-index: 10;
      display: none; /* initially hidden */
      max-width: 250px;
      font-family: Arial, sans-serif;
      font-size: 12px;
    }
    /* Toggle button styling */
    #toggleLegend {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 11;
      padding: 5px 10px;
      font-family: Arial, sans-serif;
      cursor: pointer;
    }
    /* Legend table styling */
    #legend table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    #legend th, #legend td {
      border: 1px solid #ddd;
      padding: 3px 5px;
      text-align: left;
    }
    #legend ul {
      list-style-type: none;
      padding-left: 0;
      margin: 0;
    }
    #legend li {
      margin-bottom: 3px;
    }
  </style>
</head>
<body>
  <h2>Static RDF Graph from JSON‑LD with Dynamic Legend, Highlighting & Blurred Text</h2>
  
  <!-- Network container with relative positioning -->
  <div id="network-container">
    <div id="mynetwork"></div>
    <!-- Legend overlay (dynamically generated) -->
    <div id="legend"></div>
    <!-- Toggle button for the legend -->
    <button id="toggleLegend">Show Legend</button>
  </div>
  
  <!-- Load vis-network JavaScript library from CDN -->
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <script>
    /************************************************************
     * SAMPLE JSON‑LD DATA
     ************************************************************/
    const jsonData = [
  {
    "@id": "http://example.org/Car_Instance1",
    "@type": [
      "http://schema.org/Car"
    ]
  },
  {
    "@id": "http://example.org/ishuman",
    "@type": [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"
    ],
    "http://www.w3.org/2000/01/rdf-schema#domain": [
      {
        "@id": "http://example.org/Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#range": [
      {
        "@id": "http://www.w3.org/2001/XMLSchema#string"
      }
    ]
  },
  {
    "@id": "http://example.org/Person_Instance2",
    "@type": [
      "http://xmlns.com/foaf/0.1/Person"
    ]
  },
  {
    "@id": "http://example.org/Employee_Instance2",
    "@type": [
      "http://example.org/Employee"
    ],
    "http://example.org/age": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#integer",
        "@value": 0
      }
    ],
    "http://example.org/hasCar": [
      {
        "@id": "http://example.org/Car_Instance1"
      }
    ],
    "http://example.org/hasProfilePic": [
      {
        "@id": "http://example.org/Image_Instance1"
      }
    ],
    "http://example.org/isAtHome": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#boolean",
        "@value": false
      }
    ],
    "http://example.org/ishuman": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#string",
        "@value": "unknown"
      }
    ]
  },
  {
    "@id": "http://example.org/hasProfilePic",
    "@type": [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"
    ],
    "http://www.w3.org/2000/01/rdf-schema#domain": [
      {
        "@id": "http://example.org/Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#range": [
      {
        "@id": "http://xmlns.com/foaf/0.1/Image"
      }
    ]
  },
  {
    "@id": "http://example.org/age",
    "@type": [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"
    ],
    "http://www.w3.org/2000/01/rdf-schema#domain": [
      {
        "@id": "http://example.org/Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#range": [
      {
        "@id": "http://www.w3.org/2001/XMLSchema#integer"
      }
    ]
  },
  {
    "@id": "http://example.org/Car_Instance2",
    "@type": [
      "http://schema.org/Car"
    ]
  },
  {
    "@id": "http://example.org/Image_Instance2",
    "@type": [
      "http://xmlns.com/foaf/0.1/Image"
    ]
  },
  {
    "@id": "http://example.org/Employee",
    "@type": [
      "http://www.w3.org/2000/01/rdf-schema#Class"
    ],
    "http://www.w3.org/2000/01/rdf-schema#comment": [
      {
        "@value": "A class representing an employee."
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#label": [
      {
        "@value": "Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#subClassOf": [
      {
        "@id": "http://xmlns.com/foaf/0.1/Person"
      }
    ]
  },
  {
    "@id": "http://example.org/Person_Instance1",
    "@type": [
      "http://xmlns.com/foaf/0.1/Person"
    ]
  },
  {
    "@id": "http://example.org/Employee_Instance1",
    "@type": [
      "http://example.org/Employee"
    ],
    "http://example.org/age": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#integer",
        "@value": 0
      }
    ],
    "http://example.org/hasCar": [
      {
        "@id": "http://example.org/Car_Instance1"
      }
    ],
    "http://example.org/hasProfilePic": [
      {
        "@id": "http://example.org/Image_Instance1"
      }
    ],
    "http://example.org/isAtHome": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#boolean",
        "@value": false
      }
    ],
    "http://example.org/ishuman": [
      {
        "@type": "http://www.w3.org/2001/XMLSchema#string",
        "@value": "unknown"
      }
    ]
  },
  {
    "@id": "http://example.org/hasCar",
    "@type": [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"
    ],
    "http://www.w3.org/2000/01/rdf-schema#comment": [
      {
        "@value": "A property linking an employee to their car."
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#domain": [
      {
        "@id": "http://example.org/Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#label": [
      {
        "@value": "hasCar"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#range": [
      {
        "@id": "http://schema.org/Car"
      }
    ]
  },
  {
    "@id": "http://example.org/Image_Instance1",
    "@type": [
      "http://xmlns.com/foaf/0.1/Image"
    ]
  },
  {
    "@id": "http://example.org/isAtHome",
    "@type": [
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#Property"
    ],
    "http://www.w3.org/2000/01/rdf-schema#domain": [
      {
        "@id": "http://example.org/Employee"
      }
    ],
    "http://www.w3.org/2000/01/rdf-schema#range": [
      {
        "@id": "http://www.w3.org/2001/XMLSchema#boolean"
      }
    ]
  }
]
    
    /************************************************************
     * DYNAMIC PREFIX MAPPING
     *
     * Recursively scan JSON‑LD for all URIs, extract their base (up to the last "#" or "/"),
     * and assign dynamic prefixes (p1, p2, …).
     ************************************************************/
    function generatePrefixMapping(jsonData) {
      const uriSet = new Set();
      function scan(item) {
        if (typeof item === 'string') {
          if (item.startsWith("http://") || item.startsWith("https://")) {
            uriSet.add(item);
          }
        } else if (Array.isArray(item)) {
          item.forEach(scan);
        } else if (typeof item === 'object' && item !== null) {
          for (let key in item) {
            scan(item[key]);
          }
        }
      }
      jsonData.forEach(scan);
      
      function getBase(uri) {
        if (uri.includes("#")) {
          return uri.substring(0, uri.lastIndexOf("#") + 1);
        } else {
          const lastSlash = uri.lastIndexOf("/");
          return lastSlash !== -1 ? uri.substring(0, lastSlash + 1) : uri;
        }
      }
      
      const baseSet = new Set();
      uriSet.forEach(uri => {
        baseSet.add(getBase(uri));
      });
      
      const prefixMapping = {};
      let count = 1;
      baseSet.forEach(base => {
        prefixMapping[base] = "p" + count;
        count++;
      });
      return prefixMapping;
    }
    const dynamicPrefixes = generatePrefixMapping(jsonData);
    
    /************************************************************
     * HELPER FUNCTION: shorten(uri)
     * Uses dynamicPrefixes mapping to shorten full URIs.
     ************************************************************/
    function shorten(uri) {
      for (const base in dynamicPrefixes) {
        if (uri.startsWith(base)) {
          return dynamicPrefixes[base] + ":" + uri.slice(base.length);
        }
      }
      return uri;
    }
    
    /************************************************************
     * Generate Dynamic Legend HTML
     ************************************************************/
    function generateLegendHTML(prefixMapping) {
      let html = "<h3>Legend</h3>";
      html += "<table><tr><th>Prefix</th><th>URI</th></tr>";
      for (const base in prefixMapping) {
        html += "<tr><td>" + prefixMapping[base] + "</td><td>" + base + "</td></tr>";
      }
      html += "</table>";
      html += "<p><strong>Node Types:</strong></p><ul>";
      html += '<li><span style="color: #FFA500; font-weight: bold;">Class</span>: Box (orange)</li>';
      html += '<li><span style="color: #ADFF2F; font-weight: bold;">Property</span>: Diamond (green-yellow)</li>';
      html += '<li><span style="color: #97C2FC; font-weight: bold;">Instance</span>: Dot (blue)</li>';
      html += '<li><span style="color: #FFD700; font-weight: bold;">Literal</span>: Box (yellow)</li>';
      html += "</ul>";
      return html;
    }
    document.getElementById("legend").innerHTML = generateLegendHTML(dynamicPrefixes);
    
    /************************************************************
     * HEX TO RGBA HELPER FUNCTION
     * Converts a hex color string to an rgba string with the specified alpha.
     ************************************************************/
    function hexToRgba(hex, alpha) {
      hex = hex.replace('#','');
      if(hex.length === 3) {
        hex = hex.split('').map(h => h+h).join('');
      }
      const bigint = parseInt(hex, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    
    /************************************************************
     * processJsonLd(data)
     *
     * Creates nodes and edges from the JSON‑LD.
     * Each node is given a default font with a stored baseFont color.
     ************************************************************/
    function processJsonLd(data) {
      const nodesMap = {};
      const edges = [];
      let literalCounter = 0;
      
      data.forEach(item => {
        const subjectId = item['@id'];
        let nodeType = 'instance';
        if (item['@type']) {
          const types = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
          if (types.includes("http://www.w3.org/2000/01/rdf-schema#Class")) {
            nodeType = 'class';
          } else if (types.includes("http://www.w3.org/1999/02/22-rdf-syntax-ns#Property")) {
            nodeType = 'property';
          }
        }
        if (!nodesMap[subjectId]) {
          let label = subjectId;
          if (item["http://www.w3.org/2000/01/rdf-schema#label"]) {
            label = item["http://www.w3.org/2000/01/rdf-schema#label"][0]["@value"] || subjectId;
          } else {
            label = shorten(subjectId);
          }
          let shape = 'dot';
          let color = '#97C2FC'; // blue for instances
          if (nodeType === 'class') {
            shape = 'box';
            color = '#FFA500';
          } else if (nodeType === 'property') {
            shape = 'diamond';
            color = '#ADFF2F';
          }
          nodesMap[subjectId] = { 
            id: subjectId, 
            label: label, 
            shape: shape, 
            color: color,
            baseColor: color, 
            nodeType: nodeType,
            font: { color: "#000000", baseColor: "#000000" }
          };
        }
        if (item['@type']) {
          const types = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
          types.forEach(t => {
            let typeId = (typeof t === 'string') ? t : (t['@id'] || null);
            if (typeId) {
              if (!nodesMap[typeId]) {
                nodesMap[typeId] = {
                  id: typeId,
                  label: shorten(typeId),
                  shape: 'box',
                  color: '#FFA500',
                  baseColor: '#FFA500',
                  nodeType: 'class',
                  font: { color: "#000000", baseColor: "#000000" }
                };
              }
              edges.push({
                from: subjectId,
                to: typeId,
                label: shorten("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
                dashes: true,
                color: { color: '#000000' },
                font: { color: '#000000', baseColor: '#000000' }
              });
            }
          });
        }
        Object.keys(item).forEach(prop => {
          if (prop === '@id' || prop === '@type') return;
          const values = item[prop];
          if (Array.isArray(values)) {
            values.forEach(val => {
              if (val && typeof val === 'object') {
                if (val['@id']) {
                  const targetId = val['@id'];
                  if (!nodesMap[targetId]) {
                    nodesMap[targetId] = {
                      id: targetId,
                      label: shorten(targetId),
                      shape: 'dot',
                      color: '#97C2FC',
                      baseColor: '#97C2FC',
                      nodeType: 'instance',
                      font: { color: "#000000", baseColor: "#000000" }
                    };
                  }
                  edges.push({
                    from: subjectId,
                    to: targetId,
                    label: shorten(prop),
                    arrows: 'to',
                    color: { color: '#000000' },
                    font: { color: '#000000', baseColor: '#000000' }
                  });
                } else if (val['@value']) {
                  const literalValue = String(val['@value']);
                  const literalId = `literal_${literalCounter++}`;
                  nodesMap[literalId] = {
                    id: literalId,
                    label: literalValue,
                    shape: 'box',
                    color: '#FFD700',
                    baseColor: '#FFD700',
                    nodeType: 'literal',
                    font: { color: "#000000", baseColor: "#000000" }
                  };
                  edges.push({
                    from: subjectId,
                    to: literalId,
                    label: shorten(prop),
                    arrows: 'to',
                    color: { color: '#000000' },
                    font: { color: '#000000', baseColor: '#000000' }
                  });
                }
              }
            });
          }
        });
      });
      return { nodes: Object.values(nodesMap), edges: edges };
    }
    
    const graphData = processJsonLd(jsonData);
    const nodes = new vis.DataSet(graphData.nodes);
    const edges = new vis.DataSet(graphData.edges);
    const dataForNetwork = { nodes: nodes, edges: edges };
    
    /************************************************************
     * NETWORK OPTIONS
     *
     * Physics settings are tuned for a spread-out layout.
     * After stabilization, physics is disabled to prevent bouncing,
     * yet nodes remain draggable.
     ************************************************************/
    const options = {
      layout: { improvedLayout: true },
      physics: {
        barnesHut: {
          gravitationalConstant: -3000,
          centralGravity: 0.2,
          springLength: 200,
          springConstant: 0.04,
          damping: 0.09
        },
        stabilization: {
          iterations: 2500,
          updateInterval: 25,
          fit: true
        },
        minVelocity: 0.75
      },
      edges: {
        smooth: {
          type: 'cubicBezier',
          forceDirection: 'vertical',
          roundness: 0.4
        }
      },
      interaction: {
        dragNodes: true,
        dragView: true,
        zoomView: true
      }
    };
    
    const container = document.getElementById('mynetwork');
    const network = new vis.Network(container, dataForNetwork, options);
    
    // After stabilization, disable physics.
    network.once('stabilizationIterationsDone', function () {
      network.setOptions({ physics: false });
      console.log("Physics disabled. Nodes remain draggable.");
    });
    
    /************************************************************
     * NODE & EDGE HIGHLIGHTING ON CLICK
     *
     * When a node is clicked, non-related nodes and edges are faded.
     * Both the background and text (font) colors are updated.
     * Clicking on empty space restores full opacity.
     *
     * Here we use an opacity of 0.05 for faded (blurred) elements.
     * We ensure to preserve the base color values for subsequent clicks.
     ************************************************************/
    network.on("click", function(params) {
      if (params.nodes.length === 0) {
        // Restore full opacity for all nodes and edges.
        nodes.getIds().forEach(nodeId => {
          let node = nodes.get(nodeId);
          nodes.update({ 
            id: nodeId, 
            color: node.baseColor, 
            font: { color: node.font.baseColor || node.font.color, baseColor: node.font.baseColor || node.font.color }
          });
        });
        edges.getIds().forEach(edgeId => {
          let edge = edges.get(edgeId);
          edges.update({ 
            id: edgeId, 
            color: { color: '#000000' },
            font: { color: edge.font.baseColor || edge.font.color, baseColor: edge.font.baseColor || edge.font.color }
          });
        });
      } else {
        const clickedNodeId = params.nodes[0];
        const neighborNodeIds = network.getConnectedNodes(clickedNodeId);
        const highlighted = new Set([clickedNodeId, ...neighborNodeIds]);
        nodes.getIds().forEach(nodeId => {
          let node = nodes.get(nodeId);
          if (highlighted.has(nodeId)) {
            nodes.update({ 
              id: nodeId, 
              color: node.baseColor,
              font: { color: node.font.baseColor || node.font.color, baseColor: node.font.baseColor || node.font.color }
            });
          } else {
            // Fade both background and text to an opacity of 0.05.
            nodes.update({ 
              id: nodeId, 
              color: hexToRgba(node.baseColor, 0.05),
              font: { color: hexToRgba(node.font.baseColor || node.font.color, 0.05), baseColor: node.font.baseColor || node.font.color }
            });
          }
        });
        edges.getIds().forEach(edgeId => {
          let edge = edges.get(edgeId);
          if (highlighted.has(edge.from) && highlighted.has(edge.to)) {
            edges.update({ 
              id: edgeId, 
              color: { color: '#000000' },
              font: { color: edge.font.baseColor || edge.font.color, baseColor: edge.font.baseColor || edge.font.color }
            });
          } else {
            edges.update({ 
              id: edgeId, 
              color: { color: 'rgba(0,0,0,0.05)' },
              font: { color: 'rgba(0,0,0,0.05)', baseColor: edge.font.baseColor || edge.font.color }
            });
          }
        });
      }
    });
    
    /************************************************************
     * TOGGLE LEGEND FUNCTIONALITY
     ************************************************************/
    document.getElementById("toggleLegend").addEventListener("click", function() {
      const legend = document.getElementById("legend");
      if (legend.style.display === "none" || legend.style.display === "") {
        legend.style.display = "block";
        this.textContent = "Hide Legend";
      } else {
        legend.style.display = "none";
        this.textContent = "Show Legend";
      }
    });
  </script>
</body>
</html>
